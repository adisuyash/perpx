"{\n  \"name\": \"main.luanb\",\n  \"content\": {\n    \"cells\": {\n      \"0\": {\n        \"code\": \"local sqlite3 = require('lsqlite3')\\ndb = db or sqlite3.open_memory()\\ndbAdmin = require('@rakis/DbAdmin').new(db)\\n\\n-- Create tables\\nUSERS = [[\\n  CREATE TABLE IF NOT EXISTS Users (\\n    UID TEXT PRIMARY KEY,\\n    Balance FLOAT DEFAULT 0\\n  );\\n]]\\n\\nMARKETS = [[\\n  CREATE TABLE IF NOT EXISTS Markets (\\n    MarketID TEXT PRIMARY KEY,\\n    BaseCurrency TEXT,\\n    QuoteCurrency TEXT,\\n    IndexPrice FLOAT,\\n    FundingRate FLOAT,\\n    LastFundingTime INTEGER\\n  );\\n]]\\n\\nORDERS = [[\\n  CREATE TABLE IF NOT EXISTS Orders (\\n    OrderID TEXT PRIMARY KEY,\\n    UID TEXT,\\n    MarketID TEXT,\\n    Type TEXT,\\n    Side TEXT,\\n    Amount FLOAT,\\n    Price FLOAT,\\n    Timestamp INTEGER,\\n    Status TEXT,\\n    FOREIGN KEY (UID) REFERENCES Users(UID),\\n    FOREIGN KEY (MarketID) REFERENCES Markets(MarketID)\\n  );\\n]]\\n\\nPOSITIONS = [[\\n  CREATE TABLE IF NOT EXISTS Positions (\\n    PositionID TEXT PRIMARY KEY,\\n    UID TEXT,\\n    MarketID TEXT,\\n    Side TEXT,\\n    EntryPrice FLOAT,\\n    Amount FLOAT,\\n    Leverage INTEGER,\\n    LiquidationPrice FLOAT,\\n    FOREIGN KEY (UID) REFERENCES Users(UID),\\n    FOREIGN KEY (MarketID) REFERENCES Markets(MarketID)\\n  );\\n]]\\n\\nfunction InitDb()\\n  db:exec(USERS)\\n  db:exec(MARKETS)\\n  db:exec(ORDERS)\\n  db:exec(POSITIONS)\\n  return dbAdmin:tables()\\nend\\n\\nInitDb()\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"f1096059-c69c-4b97-8e52-5208e7427055\": {\n        \"code\": \"Handlers.add(\\\"Dex.Register\\\",\\n  function (msg)\\n    return msg.Action == \\\"Register\\\"\\n  end,\\n  function (msg)\\n    -- Check if user is already registered\\n    local userCount = #dbAdmin:exec(\\n      string.format([[SELECT * from Users where UID = \\\"%s\\\";]], msg.From)\\n    )\\n    if userCount > 0 then\\n      Send({Target = msg.From, Action = \\\"Registered\\\", Data = \\\"Already Registered\\\"})\\n      print(\\\"User already registered\\\")\\n      return \\\"Already Registered\\\"\\n    end\\n    dbAdmin:exec(string.format([[\\n      INSERT INTO Users (UID, Balance) VALUES (\\\"%s\\\", 0);\\n    ]], msg.From))\\n    Send({\\n      Target = msg.From,\\n      Action = \\\"Dex.Registered\\\",\\n      Data = \\\"Successfully Registered.\\\"\\n    })\\n    print(\\\"Registered \\\" .. msg.From)\\n  end \\n)\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"a4be492f-6b35-4c4f-8b5b-b722b601098f\": {\n        \"code\": \"Handlers.add(\\\"Dex.CreateMarket\\\",\\n  function (msg)\\n    return msg.Action == \\\"CreateMarket\\\"\\n  end,\\n  function (msg)\\n    local marketId = msg.MarketID or generateUniqueId()\\n    dbAdmin:exec(string.format([[\\n      INSERT INTO Markets (MarketID, BaseCurrency, QuoteCurrency, IndexPrice, FundingRate, LastFundingTime)\\n      VALUES (\\\"%s\\\", \\\"%s\\\", \\\"%s\\\", %f, 0.0, %d);\\n    ]], marketId, msg.BaseCurrency, msg.QuoteCurrency, msg.IndexPrice, msg.Timestamp))\\n    Send({\\n      Target = msg.From,\\n      Action = \\\"Dex.MarketCreated\\\",\\n      Data = \\\"Market successfully created.\\\"\\n    })\\n    print(\\\"Created market \\\" .. marketId)\\n  end\\n)\\n\\nHandlers.add(\\\"Dex.UpdateMarket\\\",\\n  function (msg)\\n    return msg.Action == \\\"UpdateMarket\\\"\\n  end,\\n  function (msg)\\n    dbAdmin:exec(string.format([[\\n      UPDATE Markets\\n      SET IndexPrice = %f, FundingRate = %f, LastFundingTime = %d\\n      WHERE MarketID = \\\"%s\\\";\\n    ]], msg.IndexPrice, msg.FundingRate, msg.Timestamp, msg.MarketID))\\n    Send({\\n      Target = msg.From,\\n      Action = \\\"Dex.MarketUpdated\\\",\\n      Data = \\\"Market successfully updated.\\\"\\n    })\\n    print(\\\"Updated market \\\" .. msg.MarketID)\\n  end\\n)\\n\\nfunction generateUniqueId()\\n  return string.format(\\\"%x\\\", math.random(0, 2^32-1))\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"8caf4a68-bdb1-473f-82d8-343bfddb0d0b\": {\n        \"code\": \"function matchOrders(marketId)\\n  local buyOrders = dbAdmin:exec(string.format([[\\n    SELECT * FROM Orders \\n    WHERE MarketID = \\\"%s\\\" AND Side = \\\"Long\\\" AND Status = \\\"Open\\\"\\n    ORDER BY Price DESC, Timestamp ASC;\\n  ]], marketId))\\n  \\n  local sellOrders = dbAdmin:exec(string.format([[\\n    SELECT * FROM Orders \\n    WHERE MarketID = \\\"%s\\\" AND Side = \\\"Short\\\" AND Status = \\\"Open\\\"\\n    ORDER BY Price ASC, Timestamp ASC;\\n  ]], marketId))\\n  \\n  for _, buyOrder in ipairs(buyOrders) do\\n    for _, sellOrder in ipairs(sellOrders) do\\n      if buyOrder.Price >= sellOrder.Price then\\n        local matchedAmount = math.min(buyOrder.Amount, sellOrder.Amount)\\n        local matchPrice = sellOrder.Price\\n        \\n        -- Update positions\\n        updatePosition(buyOrder.UID, marketId, \\\"Long\\\", matchedAmount, matchPrice)\\n        updatePosition(sellOrder.UID, marketId, \\\"Short\\\", matchedAmount, matchPrice)\\n        \\n        -- Update orders\\n        updateOrder(buyOrder.OrderID, matchedAmount)\\n        updateOrder(sellOrder.OrderID, matchedAmount)\\n        \\n        buyOrder.Amount = buyOrder.Amount - matchedAmount\\n        sellOrder.Amount = sellOrder.Amount - matchedAmount\\n        \\n        if buyOrder.Amount == 0 then\\n          break\\n        end\\n      else\\n        break\\n      end\\n    end\\n  end\\nend\\n\\nfunction updateOrder(orderId, matchedAmount)\\n  local order = dbAdmin:exec(string.format([[\\n    SELECT * FROM Orders WHERE OrderID = \\\"%s\\\";\\n  ]], orderId))[1]\\n  \\n  local newAmount = order.Amount - matchedAmount\\n  local newStatus = newAmount == 0 and \\\"Filled\\\" or \\\"PartiallyFilled\\\"\\n  \\n  dbAdmin:exec(string.format([[\\n    UPDATE Orders \\n    SET Amount = %f, Status = \\\"%s\\\"\\n    WHERE OrderID = \\\"%s\\\";\\n  ]], newAmount, newStatus, orderId))\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"3591d062-ab79-4d47-ad67-934affbbf103\": {\n        \"code\": \"function updatePosition(userId, marketId, side, amount, price)\\n  local position = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions \\n    WHERE UID = \\\"%s\\\" AND MarketID = \\\"%s\\\";\\n  ]], userId, marketId))[1]\\n  \\n  if position then\\n    if position.Side == side then\\n      -- Increase position\\n      local newAmount = position.Amount + amount\\n      local newEntryPrice = (position.EntryPrice * position.Amount + price * amount) / newAmount\\n      \\n      dbAdmin:exec(string.format([[\\n        UPDATE Positions\\n        SET Amount = %f, EntryPrice = %f\\n        WHERE PositionID = \\\"%s\\\";\\n      ]], newAmount, newEntryPrice, position.PositionID))\\n    else\\n      -- Reduce or flip position\\n      if amount < position.Amount then\\n        -- Reduce position\\n        local newAmount = position.Amount - amount\\n        dbAdmin:exec(string.format([[\\n          UPDATE Positions\\n          SET Amount = %f\\n          WHERE PositionID = \\\"%s\\\";\\n        ]], newAmount, position.PositionID))\\n      else\\n        -- Flip position\\n        local newAmount = amount - position.Amount\\n        dbAdmin:exec(string.format([[\\n          UPDATE Positions\\n          SET Side = \\\"%s\\\", Amount = %f, EntryPrice = %f\\n          WHERE PositionID = \\\"%s\\\";\\n        ]], side, newAmount, price, position.PositionID))\\n      end\\n    end\\n  else\\n    -- Create new position\\n    local positionId = generateUniqueId()\\n    dbAdmin:exec(string.format([[\\n      INSERT INTO Positions (PositionID, UID, MarketID, Side, EntryPrice, Amount, Leverage, LiquidationPrice)\\n      VALUES (\\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", %f, %f, 1, 0);\\n    ]], positionId, userId, marketId, side, price, amount))\\n  end\\n  \\n  calculateLiquidationPrice(userId, marketId)\\nend\\n\\nfunction calculateLiquidationPrice(userId, marketId)\\n  local position = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions \\n    WHERE UID = \\\"%s\\\" AND MarketID = \\\"%s\\\";\\n  ]], userId, marketId))[1]\\n  \\n  if position then\\n    local market = dbAdmin:exec(string.format([[\\n      SELECT IndexPrice FROM Markets WHERE MarketID = \\\"%s\\\";\\n    ]], marketId))[1]\\n    \\n    local liquidationPrice\\n    if position.Side == \\\"Long\\\" then\\n      liquidationPrice = position.EntryPrice * (1 - 1 / position.Leverage)\\n    else\\n      liquidationPrice = position.EntryPrice * (1 + 1 / position.Leverage)\\n    end\\n    \\n    dbAdmin:exec(string.format([[\\n      UPDATE Positions\\n      SET LiquidationPrice = %f\\n      WHERE PositionID = \\\"%s\\\";\\n    ]], liquidationPrice, position.PositionID))\\n  end\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"4bfe9374-9337-47c0-907f-072eb6ffa07f\": {\n        \"code\": \"function calculateFundingRate(marketId)\\n  local market = dbAdmin:exec(string.format([[\\n    SELECT * FROM Markets WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))[1]\\n  \\n  local positions = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))\\n  \\n  local longValue = 0\\n  local shortValue = 0\\n  \\n  for _, position in ipairs(positions) do\\n    local positionValue = position.Amount * market.IndexPrice\\n    if position.Side == \\\"Long\\\" then\\n      longValue = longValue + positionValue\\n    else\\n      shortValue = shortValue + positionValue\\n    end\\n  end\\n  \\n  local imbalance = (longValue - shortValue) / (longValue + shortValue)\\n  local fundingRate = imbalance * 0.01 -- 1% max funding rate\\n  \\n  dbAdmin:exec(string.format([[\\n    UPDATE Markets\\n    SET FundingRate = %f, LastFundingTime = %d\\n    WHERE MarketID = \\\"%s\\\";\\n  ]], fundingRate, os.time(), marketId))\\n  \\n  return fundingRate\\nend\\n\\nfunction applyFunding(marketId)\\n  local market = dbAdmin:exec(string.format([[\\n    SELECT * FROM Markets WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))[1]\\n  \\n  local positions = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))\\n  \\n  for _, position in ipairs(positions) do\\n    local fundingAmount = position.Amount * market.IndexPrice * market.FundingRate\\n    if position.Side == \\\"Long\\\" then\\n      fundingAmount = -fundingAmount\\n    end\\n    \\n    dbAdmin:exec(string.format([[\\n      UPDATE Users\\n      SET Balance = Balance + %f\\n      WHERE UID = \\\"%s\\\";\\n    ]], fundingAmount, position.UID))\\n  end\\nend\\n\\n-- This function should be called periodically (e.g., every hour)\\nfunction updateFunding(marketId)\\n  local fundingRate = calculateFundingRate(marketId)\\n  applyFunding(marketId)\\n  print(string.format(\\\"Updated funding rate for market %s: %f\\\", marketId, fundingRate))\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"67792299-5778-4aee-a490-3a9ffd068b33\": {\n        \"code\": \"function checkLiquidations(marketId)\\n  local market = dbAdmin:exec(string.format([[\\n    SELECT IndexPrice FROM Markets WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))[1]\\n  \\n  local positions = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))\\n  \\n  for _, position in ipairs(positions) do\\n    if (position.Side == \\\"Long\\\" and market.IndexPrice <= position.LiquidationPrice) or\\n       (position.Side == \\\"Short\\\" and market.IndexPrice >= position.LiquidationPrice) then\\n      liquidatePosition(position, market.IndexPrice)\\n    end\\n  end\\nend\\n\\nfunction liquidatePosition(position, marketPrice)\\n  local pnl = calculatePnL(position, marketPrice)\\n  \\n  -- Close the position\\n  dbAdmin:exec(string.format([[\\n    DELETE FROM Positions WHERE PositionID = \\\"%s\\\";\\n  ]], position.PositionID))\\n  \\n  -- Update user balance\\n  dbAdmin:exec(string.format([[\\n    UPDATE Users\\n    SET Balance = Balance + %f\\n    WHERE UID = \\\"%s\\\";\\n  ]], pnl, position.UID))\\n  \\n  -- Create a market order to close the position\\n  local orderId = generateUniqueId()\\n  local side = position.Side == \\\"Long\\\" and \\\"Sell\\\" or \\\"Buy\\\"\\n  dbAdmin:exec(string.format([[\\n    INSERT INTO Orders (OrderID, UID, MarketID, Type, Side, Amount, Price, Timestamp, Status)\\n    VALUES (\\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"Market\\\", \\\"%s\\\", %f, %f, %d, \\\"Open\\\");\\n  ]], orderId, position.UID, position.MarketID, side, position.Amount, marketPrice, os.time()))\\n  \\n  print(string.format(\\\"Liquidated position %s for user %s\\\", position.PositionID, position.UID))\\nend\\n\\nfunction calculatePnL(position, marketPrice)\\n  local positionValue = position.Amount * marketPrice\\n  local entryValue = position.Amount * position.EntryPrice\\n  local pnl = position.Side == \\\"Long\\\" and (positionValue - entryValue) or (entryValue - positionValue)\\n  return pnl\\nend\\n\\n-- This function should be called frequently (e.g., every minute)\\nfunction runLiquidationCheck()\\n  local markets = dbAdmin:exec(\\\"SELECT MarketID FROM Markets;\\\")\\n  for _, market in ipairs(markets) do\\n    checkLiquidations(market.MarketID)\\n  end\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"b608df0d-d658-4579-a9a5-664ded501cb0\": {\n        \"code\": \"function updateUserBalance(userId, amount)\\n  dbAdmin:exec(string.format([[\\n    UPDATE Users\\n    SET Balance = Balance + %f\\n    WHERE UID = \\\"%s\\\";\\n  ]], amount, userId))\\nend\\n\\nfunction getAvailableMargin(userId)\\n  local user = dbAdmin:exec(string.format([[\\n    SELECT Balance FROM Users WHERE UID = \\\"%s\\\";\\n  ]], userId))[1]\\n  \\n  local positions = dbAdmin:exec(string.format([[\\n    SELECT * FROM Positions WHERE UID = \\\"%s\\\";\\n  ]], userId))\\n  \\n  local usedMargin = 0\\n  for _, position in ipairs(positions) do\\n    local market = dbAdmin:exec(string.format([[\\n      SELECT IndexPrice FROM Markets WHERE MarketID = \\\"%s\\\";\\n    ]], position.MarketID))[1]\\n    \\n    usedMargin = usedMargin + (position.Amount * market.IndexPrice) / position.Leverage\\n  end\\n  \\n  return user.Balance - usedMargin\\nend\\n\\nfunction canPlaceOrder(userId, marketId, amount, leverage)\\n  local availableMargin = getAvailableMargin(userId)\\n  local market = dbAdmin:exec(string.format([[\\n    SELECT IndexPrice FROM Markets WHERE MarketID = \\\"%s\\\";\\n  ]], marketId))[1]\\n  \\n  local requiredMargin = (amount * market.IndexPrice) / leverage\\n  return availableMargin >= requiredMargin\\nend\\n\\nHandlers.add(\\\"Dex.Deposit\\\",\\n  function (msg)\\n    return msg.Action == \\\"Deposit\\\"\\n  end,\\n  function (msg)\\n    updateUserBalance(msg.From, msg.Amount)\\n    Send({\\n      Target = msg.From,\\n      Action = \\\"Dex.Deposited\\\",\\n      Data = string.format(\\\"Deposited %f successfully.\\\", msg.Amount)\\n    })\\n    print(string.format(\\\"User %s deposited %f\\\", msg.From, msg.Amount))\\n  end\\n)\\n\\nHandlers.add(\\\"Dex.Withdraw\\\",\\n  function (msg)\\n    return msg.Action == \\\"Withdraw\\\"\\n  end,\\n  function (msg)\\n    local availableMargin = getAvailableMargin(msg.From)\\n    if availableMargin >= msg.Amount then\\n      updateUserBalance(msg.From, -msg.Amount)\\n      Send({\\n        Target = msg.From,\\n        Action = \\\"Dex.Withdrawn\\\",\\n        Data = string.format(\\\"Withdrawn %f successfully.\\\", msg.Amount)\\n      })\\n      print(string.format(\\\"User %s withdrew %f\\\", msg.From, msg.Amount))\\n    else\\n      Send({\\n        Target = msg.From,\\n        Action = \\\"Dex.WithdrawFailed\\\",\\n        Data = \\\"Insufficient available margin for withdrawal.\\\"\\n      })\\n    end\\n  end\\n)\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"5dd7a087-07a2-41cc-ab68-015a83d33f5a\": {\n        \"code\": \"-- dbAdmin:exec([[DELETE FROM Users WHERE UID = \\\"AgSwemqzno8dfcCy4Pc37ZcJOqPUAqCDefJTLObIC_4\\\";]])\\n-- dbAdmin:exec([[DELETE FROM Orders WHERE OrderID = \\\"d5f37073\\\";]])\\n-- dbAdmin:exec([[DELETE FROM Orders WHERE Side = \\\"Short\\\";]])\\n-- dbAdmin:exec([[DELETE FROM Positions WHERE Side = \\\"Long\\\";]])\\n-- dbAdmin:exec([[DELETE FROM Markets WHERE MarketID = \\\"2eebc8ef\\\";]])\\n-- dbAdmin:exec([[SELECT * from Users;]])\\ndbAdmin:exec([[SELECT * from Markets;]])\\n-- dbAdmin:exec([[SELECT * from Orders;]])\\n-- dbAdmin:exec([[SELECT * from Positions;]])\",\n        \"output\": \"{\\n  {\\n     \\u001b[31mFundingRate\\u001b[0m = \\u001b[34m0.003\\u001b[0m,\\n     \\u001b[31mMarketID\\u001b[0m = \\u001b[32m\\\"2298405b\\\"\\u001b[0m,\\n     \\u001b[31mIndexPrice\\u001b[0m = \\u001b[34m24.407716\\u001b[0m,\\n     \\u001b[31mBaseCurrency\\u001b[0m = \\u001b[32m\\\"AR\\\"\\u001b[0m,\\n     \\u001b[31mQuoteCurrency\\u001b[0m = \\u001b[32m\\\"USD\\\"\\u001b[0m,\\n     \\u001b[31mLastFundingTime\\u001b[0m = \\u001b[34m1720608972886\\u001b[0m\\n  }\\n }\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"92968f3e-aa04-4adb-9a55-4680572d7d60\": {\n        \"code\": \"-- Send({Target = ao.id, Action = \\\"Register\\\"})\\n-- Send({Target = ao.id, Action = \\\"CreateMarket\\\", BaseCurrency = \\\"AR\\\", QuoteCurrency = \\\"USD\\\", IndexPrice = \\\"0.0\\\"})\\n-- Send({Target = ao.id, Action = \\\"UpdateMarket\\\", IndexPrice = \\\"22.66531\\\", FundingRate = \\\"0.003\\\", MarketID = \\\"2298405b\\\"})\\n-- Send({Target = ao.id, Action = \\\"Deposit\\\", Amount = \\\"100.0\\\"})\\n-- Send({Target = ao.id, Action = \\\"Withdraw\\\", Amount = \\\"10.0\\\"})\\n-- Send({Target = ao.id, Action = \\\"GetIndexPrice\\\"})\\nSend({Target = ao.id, Action = \\\"PlaceOrder\\\", MarketID = \\\"2298405b\\\", OrderType = \\\"Short\\\", Side = \\\"Short\\\", Amount = \\\"4\\\", Price = \\\"25.1\\\", Leverage = \\\"1\\\"})\\n\",\n        \"output\": \"message added to outbox\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"34198b7b-0fef-4793-8caf-ddb2b1b46533\": {\n        \"code\": \"local json = require(\\\"json\\\")\\n\\n_0RBIT = \\\"BaMK1dfayo75s3q1ow6AO64UDpD9SEFbeE8xYrY2fyQ\\\"\\n_0RBT_TOKEN = \\\"BUhZLMwQ6yZHguLtJYA5lLUa9LQzLXMXRfaq9FVcPJc\\\"\\n\\nBASE_URL = \\\"https://api.coinbase.com/v2/prices/AR-USD/spot\\\"\\nFEE_AMOUNT = \\\"1000000000000\\\" -- 1 $0RBT\\n\\nReceivedData1 = ReceivedData1 or {}\\n\\nHandlers.add(\\n\\t\\\"Get-Request\\\",\\n\\tHandlers.utils.hasMatchingTag(\\\"Action\\\", \\\"First-Get-Request\\\"),\\n\\tfunction(msg)\\n\\t\\tSend({\\n\\t\\t\\tTarget = _0RBT_TOKEN,\\n\\t\\t\\tAction = \\\"Transfer\\\",\\n\\t\\t\\tRecipient = _0RBIT,\\n\\t\\t\\tQuantity = FEE_AMOUNT,\\n\\t\\t\\t[\\\"X-Url\\\"] = BASE_URL,\\n\\t\\t\\t[\\\"X-Action\\\"] = \\\"Get-Real-Data\\\"\\n\\t\\t})\\n\\t\\tprint(Colors.green .. \\\"You have sent a GET Request to the 0rbit process.\\\")\\n\\tend\\n)\\n\\nHandlers.add(\\n\\t\\\"ReceiveData\\\",\\n\\tHandlers.utils.hasMatchingTag(\\\"Action\\\", \\\"Receive-Response\\\"),\\n\\tfunction(msg)\\n\\t\\tlocal res = json.decode(msg.Data)\\n\\t\\tReceivedData1 = res\\n\\t\\tprint(Colors.green .. \\\"You have received the data from the 0rbit process.\\\")\\n\\tend\\n)\\n\\n-- Send({Target=\\\"BUhZLMwQ6yZHguLtJYA5lLUa9LQzLXMXRfaq9FVcPJc\\\", Action=\\\"Balance\\\"})\\n\\nfunction fetchMarketPrice(marketId)\\n\\tSend({ Target= ao.id, Action=\\\"First-Get-Request\\\" })\\n\\treturn ReceivedData1[\\\"data\\\"][\\\"amount\\\"]\\nend\\n\\nfunction updateMarketPrices()\\n  -- Update market prices (this function would need to be implemented to fetch current market prices)\\n  local markets = dbAdmin:exec(\\\"SELECT MarketID FROM Markets;\\\")\\n  for _, market in ipairs(markets) do\\n    local newPrice = fetchMarketPrice(market.MarketID)  -- Implement this function to fetch the current market price\\n    dbAdmin:exec(string.format([[\\n      UPDATE Markets SET IndexPrice = %f WHERE MarketID = \\\"%s\\\";\\n    ]], newPrice, market.MarketID))\\n    \\n    -- Check for liquidations after price update\\n    -- checkLiquidations(market.MarketID)\\n  end\\nend\\n\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"cac4df12-d59a-4c81-a701-8ee35fda3488\": {\n        \"code\": \"print(string.format(\\\"%x\\\", math.random(0, 2^32-1)))\",\n        \"output\": \"9d5ffa41\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"3068e90b-a808-405f-aa6c-07481ad7d3bc\": {\n        \"code\": \"-- print(getAvailableMargin(\\\"PVU35t7MLuI_6f73ix-GWULD5qadJBEHIr3PV7Zj75k\\\"))\\n-- print(canPlaceOrder(\\\"PVU35t7MLuI_6f73ix-GWULD5qadJBEHIr3PV7Zj75k\\\", \\\"2eebc8ef\\\", 0.01, 1))\",\n        \"output\": true,\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"00cd190b-6c0e-438a-8651-33243b65798d\": {\n        \"code\": \"Handlers.add(\\\"Dex.PlaceOrder\\\",\\n  function (msg)\\n    return msg.Action == \\\"PlaceOrder\\\"\\n  end,\\n  function (msg)\\n    local user = dbAdmin:exec(string.format([[\\n      SELECT UID, Balance from Users where UID = \\\"%s\\\";\\n    ]], msg.From))[1]\\n\\n    print(user)\\n    \\n    if user then\\n      if canPlaceOrder(user.UID, msg.MarketID, msg.Amount, msg.Leverage) then\\n        local orderId = generateUniqueId()\\n        dbAdmin:exec(string.format([[\\n          INSERT INTO Orders (OrderID, UID, MarketID, Type, Side, Amount, Price, Timestamp, Status)\\n          VALUES (\\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", %f, %f, %d, \\\"Open\\\");\\n        ]], orderId, user.UID, msg.MarketID, msg.OrderType, msg.Side, msg.Amount, msg.Price, msg.Timestamp))\\n        \\n        Send({Target = msg.From, Action = \\\"Dex.OrderPlaced\\\", Data = \\\"Order placed successfully.\\\"})\\n        print(\\\"New Order: \\\" .. orderId)\\n        \\n        -- Trigger order matching\\n        matchOrders(msg.MarketID)\\n        \\n        -- Check for liquidations after order matching\\n        checkLiquidations(msg.MarketID)\\n        \\n        return \\\"ok\\\"\\n      else\\n        Send({Target = msg.From, Action = \\\"Dex.OrderFailed\\\", Data = \\\"Insufficient margin to place order.\\\"})\\n        print(\\\"User has insufficient margin to place order\\\")\\n      end\\n    else\\n      Send({Target = msg.From, Action = \\\"Dex.OrderFailed\\\", Data = \\\"Not Registered\\\"})\\n      print(\\\"User not registered, can't place order\\\")\\n    end\\n  end\\n)\\n\\nfunction generateUniqueId()\\n  return string.format(\\\"%x\\\", math.random(0, 2^32-1))\\nend\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"75bcc1f9-7369-41b6-8519-cf0dfe34a5de\": {\n        \"code\": \"-- updateFunding(\\\"2eebc8ef\\\")\\nupdateMarketPrices()\\n-- fetchMarketPrice(\\\"ko\\\")\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"c3dabe4a-2ac2-40e1-8d90-389eba0cfcc4\": {\n        \"code\": \"Handlers.add(\\\"Dex.GetIndexPrice\\\",\\n  function (msg)\\n    return msg.Action == \\\"GetIndexPrice\\\"\\n  end,\\n  function (msg)\\n    price = dbAdmin:exec([[SELECT IndexPrice FROM Markets WHERE MarketID = \\\"2298405b\\\";]])\\n    print(price)\\n    Send({Target = msg.From, Action = \\\"Dex.GetIndexPrice\\\", Data = require('json').encode(price)})\\n  end \\n)\\n\\nHandlers.add(\\\"Dex.GetPositions\\\",\\n  function (msg)\\n    return msg.Action == \\\"GetPositions\\\"\\n  end,\\n  function (msg)\\n    positions = dbAdmin:exec([[\\n        SELECT * FROM Positions p LEFT OUTER JOIN Markets m ON p.MarketID = m.MarketID WHERE UID = \\\"njmnUpLzADMY7mfra0BODaAwTEVo0OwVS7z2nTJTD14\\\";\\n        ]])\\n    Send({Target = msg.From, Action = \\\"Dex.GetPositions\\\", Data = require('json').encode(positions)})\\n  end \\n)\\n\\nHandlers.add(\\\"Dex.GetOrderbook\\\",\\n  function (msg)\\n    return msg.Action == \\\"GetOrderbook\\\"\\n  end,\\n  function (msg)\\n    orderbook = dbAdmin:exec([[SELECT * FROM Orders WHERE Status = \\\"Open\\\";]])\\n    Send({Target = msg.From, Action = \\\"Dex.GetOrderbook\\\", Data = require('json').encode(orderbook)})\\n  end \\n)\\n\",\n        \"output\": \"\\\"undefined\\\"\",\n        \"type\": \"CODE\",\n        \"editing\": true\n      },\n      \"9146a050-65e5-4165-a009-904c839652fd\": {\n        \"code\": \"dbAdmin:exec(string.format([[\\n      INSERT INTO Users (UID, Balance) VALUES (\\\"%s\\\", 10000);\\n    ]], \\\"njmnUpLzADMY7mfra0BODaAwTEVo0OwVS7z2nTJTD14\\\"))\",\n        \"output\": {},\n        \"type\": \"CODE\",\n        \"editing\": true\n      }\n    },\n    \"cellOrder\": [\n      \"0\",\n      \"f1096059-c69c-4b97-8e52-5208e7427055\",\n      \"9146a050-65e5-4165-a009-904c839652fd\",\n      \"a4be492f-6b35-4c4f-8b5b-b722b601098f\",\n      \"cac4df12-d59a-4c81-a701-8ee35fda3488\",\n      \"8caf4a68-bdb1-473f-82d8-343bfddb0d0b\",\n      \"3591d062-ab79-4d47-ad67-934affbbf103\",\n      \"4bfe9374-9337-47c0-907f-072eb6ffa07f\",\n      \"67792299-5778-4aee-a490-3a9ffd068b33\",\n      \"b608df0d-d658-4579-a9a5-664ded501cb0\",\n      \"3068e90b-a808-405f-aa6c-07481ad7d3bc\",\n      \"34198b7b-0fef-4793-8caf-ddb2b1b46533\",\n      \"92968f3e-aa04-4adb-9a55-4680572d7d60\",\n      \"00cd190b-6c0e-438a-8651-33243b65798d\",\n      \"75bcc1f9-7369-41b6-8519-cf0dfe34a5de\",\n      \"c3dabe4a-2ac2-40e1-8d90-389eba0cfcc4\",\n      \"5dd7a087-07a2-41cc-ab68-015a83d33f5a\"\n    ]\n  },\n  \"language\": \"lua\",\n  \"type\": \"NOTEBOOK\"\n}"